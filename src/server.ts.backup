import express, { Request, Response, NextFunction } from 'express';
import 'express-async-errors';
import cors from 'cors';
import jwt from 'jsonwebtoken';
import { PrismaClient } from '@prisma/client';
import { z } from 'zod';
import pino from 'pino';
import pinoHttp from 'pino-http';
import { logEvent } from './services/eventsClient';
import { generateContent } from './services/llmClient';
import { addToQueue } from './services/queueClient';

const app = express();
const logger = pino({ level: process.env.LOG_LEVEL || 'info' });
app.use(cors());
app.use(express.json({ limit: '1mb' }));
app.use(pinoHttp({ logger }));

const PORT = parseInt(process.env.PORT || '8800', 10) || 8080;
const SERVICE_NAME = process.env.SERVICE_NAME || 'mitkadem-writer';
const SERVICE_JWT_SECRET = process.env.SERVICE_JWT_SECRET!;
const DEV_ADMIN_SECRET = process.env.DEV_ADMIN_SECRET || '';
const INSIGHTS_URL = process.env.INSIGHTS_URL || 'https://mitkadem-insights-production.up.railway.app';

const db = new (class extends PrismaClient {})();

// --- Helper: get service token for internal calls ---
function getServiceToken(): string {
  return jwt.sign(
    { sub: 'writer-service', aud: 'internal', iss: SERVICE_NAME },
    SERVICE_JWT_SECRET,
    { expiresIn: '5m' }
  );
}

// --- health/ready ---
app.get('/healthz', (_req: Request, res: Response) =>
  res.json({ ok: true, early: true })
);
app.get('/readyz', async (_req: Request, res: Response) => {
  try {
    await db.$queryRaw`SELECT 1`;
    res.json({ ready: true });
  } catch (e: any) {
    res.status(500).json({ ready: false, error: e?.message });
  }
});

// --- dev mint ---
app.post('/v1/_dev/mint', (req: Request, res: Response) => {
  const dev = String(req.headers['x-dev-secret'] || '');
  if (dev !== DEV_ADMIN_SECRET)
    return res.status(401).json({ error: 'bad dev secret' });
  const sub = (req.body?.name as string) ?? 'svc:cli';
  const token = jwt.sign(
    { sub, aud: 'internal', iss: SERVICE_NAME },
    SERVICE_JWT_SECRET,
    { expiresIn: '1h' }
  );
  res.json({ token });
});

// --- auth ---
function auth(req: Request, res: Response, next: NextFunction) {
  const h = String(req.headers.authorization || '');
  const token = h.startsWith('Bearer ') ? h.slice(7) : '';
  try {
    jwt.verify(token, SERVICE_JWT_SECRET);
    return next();
  } catch {
    return res.status(401).json({ error: 'unauthorized' });
  }
}

// --- schemas ---
const Brief = z.object({
  tenantId: z.string().uuid(),
  brief: z.string().min(5),
  tone: z.string().optional(),
  audience: z.string().optional(),
  platform: z.string().optional()
});

const Run = z.object({ taskId: z.string().uuid() });

const FeedbackSchema = z.object({
  tenantId: z.string().uuid(),
  contentId: z.string().min(1),
  feedbackType: z.enum(['approved', 'edited', 'rejected', 'published']),
  score: z.number().min(1).max(5).optional(),
  comment: z.string().optional(),
  originalContent: z.string().optional(),
  editedContent: z.string().optional(),
  rejectionReason: z.string().optional()
});

// --- routes ---
app.post('/v1/write/brief', auth, async (req: Request, res: Response) => {
  const p = Brief.parse(req.body);
  const task = await db.writeTask.create({
    data: {
      tenantId: p.tenantId,
      brief: p.brief,
      tone: p.tone,
      audience: p.audience,
      status: 'queued'
    }
  });
  const jobId = await addToQueue('writer', task.id, task.tenantId);
  if (jobId) {
    res.status(202).json({ ...task, async: true, jobId });
  } else {
    res.status(201).json(task);
  }
});

app.post('/v1/write/run', auth, async (req: Request, res: Response) => {
  const { taskId } = Run.parse(req.body);
  const task = await db.writeTask.findUnique({ where: { id: taskId } });
  if (!task) return res.status(404).json({ error: 'not found' });

  // Get hints from insights for better generation
  let hints: any = {};
  try {
    const hintsRes = await fetch(
      `${INSIGHTS_URL}/v1/insights/hints/writer?tenantId=${task.tenantId}`,
      {
        headers: { 'Authorization': `Bearer ${getServiceToken()}` }
      }
    );
    if (hintsRes.ok) {
      const hintsData = await hintsRes.json();
      hints = hintsData.hints || {};
      logger.info({ tenantId: task.tenantId, hints }, 'Got hints from insights');
    }
  } catch (e) {
    logger.warn({ error: e }, 'Failed to get hints from insights');
  }

  // Log start
  try {
    logEvent({
      tenantId: task.tenantId,
      workflowId: null,
      eventType: 'agent.writer.run.start',
      source: 'writer',
      value: 1,
      meta: {
        taskId: task.id,
        brief: task.brief,
        tone: task.tone,
        audience: task.audience,
        hasHints: Object.keys(hints).length > 0
      }
    }).catch(() => {});
  } catch {}

  // REAL LLM generation with hints!
  let result: { content: string; hashtags: string[]; image_prompt: string };
  try {
    result = await generateContent({
      tenantId: task.tenantId,
      brief: task.brief,
      tone: hints.tone || task.tone || undefined,
      audience: task.audience || undefined,
      hints: hints // Pass hints to LLM client
    });
  } catch (err: any) {
    logger.error({ err, taskId }, 'LLM generation failed');
    return res.status(500).json({ error: 'llm_generation_failed', details: err?.message });
  }

  const updated = await db.writeTask.update({
    where: { id: task.id },
    data: { status: 'done', content: result.content }
  });

  // Log completion
  try {
    logEvent({
      tenantId: updated.tenantId,
      workflowId: null,
      eventType: 'agent.writer.run.done',
      source: 'writer',
      value: 1,
      meta: {
        taskId: updated.id,
        contentLen: updated.content ? updated.content.length : 0
      }
    }).catch(() => {});
  } catch {}

  res.json({ ...updated, image_prompt: result.image_prompt, hashtags: result.hashtags });
});

app.get('/v1/write/:id', auth, async (req: Request, res: Response) => {
  const t = await db.writeTask.findUnique({ where: { id: req.params.id } });
  if (!t) return res.status(404).json({ error: 'not found' });
  res.json(t);
});

// =============================================================================
// D3: FEEDBACK & HINTS ENDPOINTS
// =============================================================================

// POST /v1/writer/feedback - Submit feedback on generated content
app.post('/v1/writer/feedback', auth, async (req: Request, res: Response) => {
  const p = FeedbackSchema.parse(req.body);

  logger.info({ tenantId: p.tenantId, contentId: p.contentId, type: p.feedbackType }, 'Received feedback');

  // Send to insights service
  try {
    const insightsRes = await fetch(`${INSIGHTS_URL}/v1/metrics/feedback`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getServiceToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        generationId: p.contentId,
        tenantId: p.tenantId,
        action: p.feedbackType,
        contentPreview: p.originalContent?.slice(0, 200),
        editedContent: p.editedContent,
        rejectionReason: p.rejectionReason,
        originalContent: p.originalContent,
        sourceService: 'writer'
      })
    });

    if (!insightsRes.ok) {
      const error = await insightsRes.text();
      logger.error({ error }, 'Failed to send feedback to insights');
    }

    const insightsData = await insightsRes.json();

    // Also send learning event
    await fetch(`${INSIGHTS_URL}/v1/insights/learning-event`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${getServiceToken()}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        tenantId: p.tenantId,
        eventType: 'feedback_received',
        service: 'writer',
        data: {
          contentId: p.contentId,
          feedbackType: p.feedbackType,
          score: p.score,
          hasEdit: !!p.editedContent
        }
      })
    });

    res.json({
      ok: true,
      feedbackType: p.feedbackType,
      insightsResponse: insightsData
    });

  } catch (e: any) {
    logger.error({ error: e.message }, 'Error sending feedback');
    res.status(500).json({ error: 'feedback_failed', message: e.message });
  }
});

// GET /v1/writer/hints - Get personalized hints for content generation
app.get('/v1/writer/hints', auth, async (req: Request, res: Response) => {
  const tenantId = req.query.tenantId as string;

  if (!tenantId) {
    return res.status(400).json({ error: 'tenantId required' });
  }

  try {
    const hintsRes = await fetch(
      `${INSIGHTS_URL}/v1/insights/hints/writer?tenantId=${tenantId}`,
      {
        headers: { 'Authorization': `Bearer ${getServiceToken()}` }
      }
    );

    if (!hintsRes.ok) {
      const error = await hintsRes.text();
      logger.error({ error }, 'Failed to get hints from insights');
      return res.status(hintsRes.status).json({ error: 'hints_fetch_failed' });
    }

    const hintsData = await hintsRes.json();
    res.json(hintsData);

  } catch (e: any) {
    logger.error({ error: e.message }, 'Error fetching hints');
    res.status(500).json({ error: 'hints_failed', message: e.message });
  }
});

// =============================================================================
// ERROR HANDLER
// =============================================================================

app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
  logger.error({ err }, 'unhandled_error');
  res
    .status(err?.status || 500)
    .json({ error: err?.message || 'internal error' });
});
process.on('unhandledRejection', (e) =>
  logger.error({ err: e }, 'unhandledRejection')
);
process.on('uncaughtException', (e) =>
  logger.error({ err: e }, 'uncaughtException')
);

// bind
app.listen(
  process.env.PORT ? Number(process.env.PORT) : PORT,
  '0.0.0.0',
  () => {
    logger.info(
      { port: process.env.PORT || PORT, service: SERVICE_NAME },
      'service up'
    );
  }
);
